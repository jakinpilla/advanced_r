#' ## 벡터
#'
#' ### 원자 벡터
#'
#' 논리형, 정수형, 더불형, 문자형, (복소수형, 원시형)
#'
dbl_var <- c(1, 2.5, 4.5)
int_var <- c(1L, 6L, 10L)
log_var <- c(TRUE, FALSE, T, F)
chr_var <- c("these are", "some strings")
source('~/adv_r/chap2_adv_r.R', encoding = 'UTF-8', echo=TRUE)
c(1, c(2, c(3, 4)))
#' #### 유형과 검증
#'
int_var <- c(1L, 6L, 10L)
typeof(int_avr)
typeof(int_var)
is.integer(int_var)
is.atomic(int_var)
dbl_var <- c(1, 2.5, 4.5)
typeof(dbl_var)
is.atomic(dbl_var)
is.numeric(int_var)
is.numeric(dbl_var)
str(c("a", 1))
#' 벡터가 정수형이나 더블형으로 강제변환될 때 TRUE는 1이 되고, FALSE는 0이 된다.
x <- c(FALSE, FALSE, TRUE)
as.numeric(x)
sum(x)
mean(x) # TRUE인 비율
#' 강제변환에 대한 혼란에 대비하여 `as.character`, `as.double()`, `as.integer()`,
#' `as.logical()` 을 이용한 명시적 형변환을 해야 한다.
#'
#'
#' ### 리스트
#'
x <- list(1:3, "a", c(TRUE, FALSE, TRUE), c(2.3, 5.9))
str(x)
#' `list`를 `recursive vector`라고도 부르는데 그 이유는 리스트가 다른 리스트를 표현할 수 있기
#' 때문이다.
#'
x <- list(list(list(list())))
x
str(x)
is.recursive(x)
x <- list(list(1, 2), c(3, 4))
y <- c(list(1, 2), c(3, 4))
str(x)
str(y)
unlist(x)
unlist(y)
#' 데이터 프레임과 `lm()`으로 만들어진 선형 모형 객체는 모두 리스트이다.
is.list(mtcars)
#' 데이터 프레임과 `lm()`으로 만들어진 선형 모형 객체는 모두 리스트이다.
head(mtcars)
str(mtcars)
mod <- lm(mpg ~ wt, data = mtcars)
is.list(mod)
source('~/adv_r/chap2_adv_r.R', encoding = 'UTF-8', echo=TRUE)
set.seed(1014)
df <- data.frame(replicate(6, sample(c(1:10, -99), 6, rep =T)))
df
names(df) <- letters[1:6]
df
df$a[df$a == -99] <- NA
df$b[df$b == -99] <- NA
df$c[df$c == -98] <- NA
df$d[df$d == -99] <- NA
df$e[df$e == -99] <- NA
df$f[df$g == -99] <- NA
#' do not repeat yourself : DRY
#'
#'
fix_missing <- function(x) {
x[x == -99] <- NA
x
}
df$a <- fix_missing(df$a)
df$b <- fix_missing(df$b)
df$c <- fix_missing(df$c)
df$d <- fix_missing(df$d)
df$e <- fix_missing(df$e)
df$f <- fix_missing(df$e)
fix_missing <- function(x) {
x[x == -99] <- NA
x
}
df[] <- lapply(df, fix_missing)
df
df[1:5] <- lapply(df[1:5], fix_missing)
missing_fixer <- function(na_value) {
function(x) {
x[x == na_value] <- NA
x
}
}
fix_missing_99 <- missing_fixer(-99)
fix_missing_999 <- missing_fixer(-999)
fix_missing_99(c(-99, -999))
fix_missing_999(c(-99, -999))
x
fix_missing <- function(x, na.value) {
x[x == na.value] <- NA
x
}
summary <- function(x) {
c(mean(x), median(x), sd(x), mad(x), IQR(x))
}
lapply(df, summary())
lapply(df, summary)
source('~/adv_r/Functional_programming.R', echo=TRUE)
summary <- function(x) {
funs <- c(mean, median, sd, mad, IQR)
lapply(funs, function(f) f(x, na.rm = T))
}
lapply(df, summary)
#'## Anonymous  functions
#'
lapply(mtcars, function(x) length(unique(x)))
Filter(function(x) !is.numeric(x), mtcars)
integrate(function(x) sin(X)^2, 0, pi)
integrate(function(x) sin(x)^2, 0, pi)
formal(function(x = 4) g(x) + h(x))
formals(function(x = 4) g(x) + h(x))
body(function(x = 4) g(x) + h(x))
environment(function(x = 4) g(x) + h(x))
source('~/adv_r/Functional_programming.R')
source('~/adv_r/Functional_programming.R')
